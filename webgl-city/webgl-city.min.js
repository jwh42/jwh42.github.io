class Renderable{}function throwIfNull(t,e){if(null==t)throw new Error("Argument cannot be null: "+e);return t}class ResourceLoader{constructor(t){this.gl=t,this._fshaders=new Map,this._vshaders=new Map,this._textures=new Map,this._renderers=new Map,this._modelTypes=new Map,throwIfNull(t,"gl")}addModelType(t,e){this._modelTypes.set(t,e)}getModelShaderAsync(t){const e=this._renderers.get(t);if(!e)throw new Error("Unknown renderer "+t);return e}async loadShader(t,e,r){const i=await this.loadShaderProgramAsync(`shaders/${e}-Vertex.glsl`,`shaders/${e}-Fragment.glsl`);this.addModelShader(t,new r(this.gl,i))}addModelShader(t,e){this._renderers.set(t,e instanceof Promise?e:Promise.resolve(e))}async loadModelAsync(t){try{const e=await fetch(t),r=await e.json(),i=r.type,s=this._modelTypes.get(i);if(!s)throw new Error("Unknown model type: "+i);const o=new s(this.gl);return await o.configureAsync(r,this),o}catch(e){throw console.error(`Could not load ${t}`,e),e}}async loadShaderProgramAsync(t,e){const r=this.gl,i=await Promise.all([this.getVertexShaderAsync(t),this.getFragmentShaderAsync(e)]),s=r.createProgram();if(r.attachShader(s,i[0]),r.attachShader(s,i[1]),r.linkProgram(s),!r.getProgramParameter(s,r.LINK_STATUS))throw new Error(`Could not link shaders '${t}' and '${e}'`);return s}getFragmentShaderAsync(t){return this._getShader(t,this.gl.FRAGMENT_SHADER,this._fshaders)}getVertexShaderAsync(t){return this._getShader(t,this.gl.VERTEX_SHADER,this._vshaders)}getTextureAsync(t){let e=this._textures.get(t);return null==e&&(e=this._loadTexture(t),this._textures.set(t,e)),e}_getShader(t,e,r){let i=r.get(t);return null==i&&(i=this._loadShader(t,e),r.set(t,i)),i}_loadTexture(t){return new Promise((e,r)=>{const i=new Image,s=this.gl.createTexture();i.onerror=()=>{r(new Error("Could not load image "+t))},i.onload=()=>{const t=this.gl;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!0),t.bindTexture(t.TEXTURE_2D,s),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,i),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.generateMipmap(t.TEXTURE_2D),t.bindTexture(t.TEXTURE_2D,null),e(s)},i.src=t})}_loadShader(t,e){return fetch(t).then(t=>t.text()).then(t=>{const r=this.gl,i=r.createShader(e);if(r.shaderSource(i,t),r.compileShader(i),!r.getShaderParameter(i,r.COMPILE_STATUS))throw new Error(r.getShaderInfoLog(i));return i})}}class Model extends Renderable{}class BuildingModel extends Model{constructor(){super(...arguments),this._levels=new Array}render(t){for(let e=0,r=this._levels.length;e<r;e++){const r=this._levels[e];r.shader.render(t,r)}}configureAsync(t,e){const r=e.gl,i=[],s=t.angleCount,o=this._createIndexBuffer(r,s),a=this._createTexCoordBuffer(r,s),n=this._createTanCoordBuffer(r,s);let h=0,_=[];_.push(this._createVertexRingCoords(s,t.base,0));for(let e=0,r=t.levels.length;e<r;e++){const r=t.levels[e];h+=r.height,_.push(this._createVertexRingCoords(s,r.r,h))}const l=[];l.push(this._createNormalRingCoords(s,_[0],_[0],_[1]));for(let t=1,e=_.length-1;t<e;t++)l.push(this._createNormalRingCoords(s,_[t-1],_[t],_[t+1]));l.push(this._createNormalRingCoords(s,_[_.length-2],_[_.length-1],_[_.length-1]));for(let h=0,u=t.levels.length;h<u;h++){const u=new BuildingLevel(this._createPointBuffer(r,s,_[h+0],_[h+1]),this._createPointBuffer(r,s,l[h+0],l[h+1]),n,a,o,6*s);i.push(u.configureAsync(t.levels[h],e)),this._levels.push(u)}return Promise.all(i)}_createVertexRingCoords(t,e,r){const i=new Float32Array(3*t+3);let s=0,o=0;for(let a=0;a<e.length;a+=2){const n=e[a+0],h=e[a+1];for(let e=0;e<h;e++){const e=2*Math.PI*(o/t);i[s+0]=n*Math.cos(e),i[s+1]=r,i[s+2]=n*Math.sin(e),s+=3,o+=1}}const a=e[0],n=2*Math.PI*(o/t);return i[s+0]=a*Math.cos(n),i[s+1]=r,i[s+2]=a*Math.sin(n),i}_createNormalRingCoords(t,e,r,i){const s=new Float32Array(3*t+3);this._calculateNormal(s,t-2,0,1,e,r,i);for(let o=1;o<t;o++)this._calculateNormal(s,o-1,o,o+1,e,r,i);return this._calculateNormal(s,t-1,t+0,1,e,r,i),s}_calculateNormal(t,e,r,i,s,o,a){this._addCrossProd3(t,r,o,r,a,r,o,i),this._addCrossProd3(t,r,o,r,o,i,s,r),this._addCrossProd3(t,r,o,r,s,r,o,e),this._addCrossProd3(t,r,o,r,o,e,a,r),this._normalize3(t,r)}_addCrossProd3(t,e,r,i,s,o,a,n){const h=s[3*o+0]-r[3*i+0],_=s[3*o+1]-r[3*i+1],l=s[3*o+2]-r[3*i+2],u=a[3*n+0]-r[3*i+0],f=a[3*n+1]-r[3*i+1],c=a[3*n+2]-r[3*i+2];t[3*e+0]+=_*c-l*f,t[3*e+1]+=-h*c+l*u,t[3*e+2]+=h*f-_*u}_normalize3(t,e){const r=t[3*e+0],i=t[3*e+1],s=t[3*e+2],o=Math.sqrt(r*r+i*i+s*s);o>0&&(t[3*e+0]=r/o,t[3*e+1]=i/o,t[3*e+2]=s/o)}_createPointBuffer(t,e,r,i){const s=t.createBuffer(),o=3*e+3;return t.bindBuffer(t.ARRAY_BUFFER,s),t.bufferData(t.ARRAY_BUFFER,8*o,t.STATIC_DRAW),t.bufferSubData(t.ARRAY_BUFFER,0,r),t.bufferSubData(t.ARRAY_BUFFER,4*o,i),s}_createIndexBuffer(t,e){const r=t.createBuffer(),i=new Uint16Array(6*e);for(let t=0;t<e;t++)i[6*t+0]=t,i[6*t+1]=t+(e+1),i[6*t+2]=t+(e+1)+1,i[6*t+3]=t,i[6*t+4]=t+(e+1)+1,i[6*t+5]=t+1;return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,r),t.bufferData(t.ELEMENT_ARRAY_BUFFER,i,t.STATIC_DRAW),r}_createTexCoordBuffer(t,e){const r=new Float32Array(4*e+4);this._populateTexCoordRing(r,0,e,0),this._populateTexCoordRing(r,2*(e+1),e,1);const i=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,i),t.bufferData(t.ARRAY_BUFFER,r,t.STATIC_DRAW),i}_createTanCoordBuffer(t,e){const r=new Float32Array(6*e+6);this._populateTanCoordRing(r,0,e,0),this._populateTanCoordRing(r,3*(e+1),e,1);const i=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,i),t.bufferData(t.ARRAY_BUFFER,r,t.STATIC_DRAW),i}_populateTexCoordRing(t,e,r,i){let s=0;for(let o=e,a=e+2*r;o<=a;o+=2)t[o+0]=s/r,t[o+1]=i,s+=1}_populateTanCoordRing(t,e,r,i){let s=Math.PI/2,o=2*Math.PI/r;for(let i=e,a=e+3*r;i<=a;i+=3)t[i+0]=Math.cos(s),t[i+1]=Math.sin(s),t[i+2]=0,s+=o}}class BuildingLevel{constructor(t,e,r,i,s,o){this.vertexBuffer=t,this.normalBuffer=e,this.tangentBuffer=r,this.texCoordBuffer=i,this.indexBuffer=s,this.indexCount=o,this.shader=null,this.texture=null,this.bumpMap=null}async configureAsync(t,e){const[r,i]=await Promise.all([e.getModelShaderAsync(t.shader),e.getTextureAsync(t.texture)]);this.shader=r,this.texture=i,t.bumpMap&&(this.bumpMap=await e.getTextureAsync(t.bumpMap))}}function V3_mul_S1(t,e,r,i,s){const o=3*e,a=3*i;t[o+0]=s*r[a+0],t[o+1]=s*r[a+1],t[o+2]=s*r[a+2]}function V3_add_V3(t,e,r,i,s,o){const a=3*e,n=3*i,h=3*o;t[a+0]=r[n+0]+s[h+0],t[a+1]=r[n+1]+s[h+1],t[a+2]=r[n+2]+s[h+2]}function V3_sub_V3(t,e,r,i,s,o){const a=3*e,n=3*i,h=3*o;t[a+0]=r[n+0]-s[h+0],t[a+1]=r[n+1]-s[h+1],t[a+2]=r[n+2]-s[h+2]}function V3_copy_V3(t,e,r,i){const s=3*e,o=3*i;t[s+0]=r[o+0],t[s+1]=r[o+1],t[s+2]=r[o+2]}function M4_mul_V4(t,e,r,i,s){const o=4*e,a=4*s,n=i[a+0],h=i[a+1],_=i[a+2],l=i[a+3];t[o+0]=n*r[0]+h*r[1]+_*r[2]+l*r[3],t[o+1]=n*r[4]+h*r[5]+_*r[6]+l*r[7],t[o+2]=n*r[8]+h*r[9]+_*r[10]+l*r[11],t[o+3]=n*r[12]+h*r[13]+_*r[14]+l*r[15]}function M4_mul_M4(t,e,r){const i=e[0],s=e[1],o=e[2],a=e[3],n=e[4],h=e[5],_=e[6],l=e[7],u=e[8],f=e[9],c=e[10],d=e[11],m=e[12],A=e[13],x=e[14],M=e[15];let p=r[0],g=r[1],R=r[2],T=r[3];t[0]=p*i+g*n+R*u+T*m,t[1]=p*s+g*h+R*f+T*A,t[2]=p*o+g*_+R*c+T*x,t[3]=p*a+g*l+R*d+T*M,p=r[4],g=r[5],R=r[6],T=r[7],t[4]=p*i+g*n+R*u+T*m,t[5]=p*s+g*h+R*f+T*A,t[6]=p*o+g*_+R*c+T*x,t[7]=p*a+g*l+R*d+T*M,p=r[8],g=r[9],R=r[10],T=r[11],t[8]=p*i+g*n+R*u+T*m,t[9]=p*s+g*h+R*f+T*A,t[10]=p*o+g*_+R*c+T*x,t[11]=p*a+g*l+R*d+T*M,p=r[12],g=r[13],R=r[14],T=r[15],t[12]=p*i+g*n+R*u+T*m,t[13]=p*s+g*h+R*f+T*A,t[14]=p*o+g*_+R*c+T*x,t[15]=p*a+g*l+R*d+T*M}class Spline3{constructor(t){this._count=t,this._tempV4=new Float32Array(4),this._tempM4=new Float32Array(16),this._points=new Float32Array(3*this._count),this._tangents=new Float32Array(3*this._count)}get count(){return this._count}getX(t){return this._points[3*t+0]}getY(t){return this._points[3*t+1]}getZ(t){return this._points[3*t+0]}setv(t,e){this.set(t,e[0],e[1],e[2])}set(t,e,r,i){const s=3*t,o=this._points;o[s+0]=e,o[s+1]=r,o[s+2]=i,this._recalculateTangent(Math.max(t-1,0)),this._recalculateTangent(Math.min(t+1,this._count-1))}createBuffer(t){const e=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,this._points,t.STATIC_DRAW),e}interpolate(t,e,r){const i=this._points,s=Math.min(Math.max(r,0),1)*(this._count-1),o=0|s,a=s-o;if(a<=0)return void V3_copy_V3(t,e,i,o);if(a>=1)return void V3_copy_V3(t,e,i,o+1);const n=this._tempV4;n[0]=a*a*a,n[1]=a*a,n[2]=a,n[3]=1;const h=3*o,_=this._tangents,l=this._tempM4,u=Spline3._hermite;l[0]=i[h+0],l[1]=_[h+0],l[2]=i[h+3],l[3]=_[h+3],l[4]=i[h+1],l[5]=_[h+1],l[6]=i[h+4],l[7]=_[h+4],l[8]=i[h+2],l[9]=_[h+2],l[10]=i[h+5],l[11]=_[h+5],l[12]=1,l[13]=1,l[14]=1,l[15]=1,M4_mul_V4(n,0,u,n,0),M4_mul_V4(n,0,l,n,0),V3_copy_V3(t,e,n,0)}_recalculateTangent(t){const e=this._points,r=this._tangents,i=Math.max(t-1,0);V3_sub_V3(r,t,e,Math.min(t+1,this._count-1),e,i),V3_mul_S1(r,t,r,t,.5)}}Spline3._hermite=new Float32Array([2,-3,0,1,1,-2,1,0,-2,3,0,0,1,-1,0,0]);const KeyCodes={space:"Space",shiftL:"ShiftLeft",shiftR:"ShiftRight",pageUp:"PageUp",pageDown:"PageDown",left:"ArrowLeft",up:"ArrowUp",right:"ArrowRight",down:"ArrowDown",a:"KeyA",c:"KeyC",d:"KeyD",e:"KeyE",q:"KeyQ",r:"KeyR",t:"KeyT",w:"KeyW",s:"KeyS",x:"KeyX",z:"KeyZ"};class CameraModel extends Model{constructor(){super(...arguments),this._userMoveV=.06875,this._userScrlV=.34375,this._userLookV=.0010938,this._userPntrV=625e-7,this._trackColorCamera=new Float32Array([1,0,0]),this._trackColorLookAt=new Float32Array([0,0,1]),this._keysDown=new Set,this._tempPt0=new Float32Array(3),this._tempPt1=new Float32Array(3),this._restoreCameraSpline=new Spline3(2),this._restoreLookAtSpline=new Spline3(2),this._cameraX=0,this._cameraY=20,this._cameraZ=30,this._lookAtY=0,this._lookAtXZ=0,this._userMode=!1,this._userModeStartTime=0,this._userModeLookDist=20,this._userModeLastTick=0,this._pointerLocked=!1,this._pointerDx=0,this._pointerDy=0,this._scrollWheel=0,this._autoDuration=1e4,this._autoTimeOffset=0,this._autoTrackWidth=5,this._autoShowTracks=!1,this._autoRestoreStartTime=0,this._autoRestoreDuration=1500,this._autoCameraSpline=null,this._autoLookAtSpline=null,this._cameraBuffer=null,this._lookAtBuffer=null,this._mvpMatrixUniform=null,this._lineColorUniform=null,this._lineProgram=null,this._lineVertexBuffer=-1,this._targetElement=null,this._handleKeyDown=t=>{switch(this._keysDown.add(t.code),t.code){case KeyCodes.t:this._toggleCameraMode();break;case KeyCodes.r:this._autoShowTracks=!this._autoShowTracks}},this._handleKeyUp=t=>{this._keysDown.delete(t.code)},this._handlePointerDown=()=>{this._userMode&&this._targetElement.requestPointerLock()},this._handleScrollWheel=t=>(this._scrollWheel=Math.max(-1,Math.min(1,t.deltaY)),!1),this._handlePointerLockChange=()=>{this._pointerLocked=this._targetElement===document.pointerLockElement||this._targetElement===document.mozPointerLockElement},this._handlePointerMoved=t=>{this._pointerLocked&&(this._pointerDx=t.movementX,this._pointerDy=t.movementY)}}bindInputListeners(t){this._targetElement=t,document.addEventListener("keydown",this._handleKeyDown,!1),document.addEventListener("keyup",this._handleKeyUp,!1),document.addEventListener("pointermove",this._handlePointerMoved,!1),document.addEventListener("pointerlockchange",this._handlePointerLockChange,!1),t.addEventListener("pointerdown",this._handlePointerDown,!1),t.addEventListener("wheel",this._handleScrollWheel,!1)}updateCamera(t){this._userMode?this._updateUserCamera(t):this._updateAutoCamera(t),this._pointerDx=0,this._pointerDy=0,this._scrollWheel=0}render(t){if(this._autoShowTracks){const e=t.gl;e.lineWidth(this._autoTrackWidth),e.useProgram(this._lineProgram),e.enableVertexAttribArray(this._lineVertexBuffer),t.modelViewProjToUniform4fv(this._mvpMatrixUniform),e.uniform3fv(this._lineColorUniform,this._trackColorCamera),e.bindBuffer(e.ARRAY_BUFFER,this._cameraBuffer),e.vertexAttribPointer(this._lineVertexBuffer,3,e.FLOAT,!1,0,0),e.drawArrays(e.LINE_STRIP,0,this._autoCameraSpline.count),e.uniform3fv(this._lineColorUniform,this._trackColorLookAt),e.bindBuffer(e.ARRAY_BUFFER,this._lookAtBuffer),e.vertexAttribPointer(this._lineVertexBuffer,3,e.FLOAT,!1,0,0),e.drawArrays(e.LINE_STRIP,0,this._autoLookAtSpline.count),e.disableVertexAttribArray(this._lineVertexBuffer)}}async configureAsync(t,e){const r=t.points,i=r.length/6|0;this._autoDuration=t.duration,this._autoCameraSpline=new Spline3(i),this._autoLookAtSpline=new Spline3(i);for(let t=0,e=0;t<r.length;t+=6,e++)this._autoCameraSpline.set(e,r[t+0],r[t+1],r[t+2]),this._autoLookAtSpline.set(e,r[t+3],r[t+4],r[t+5]);this._cameraBuffer=this._autoCameraSpline.createBuffer(e.gl),this._lookAtBuffer=this._autoLookAtSpline.createBuffer(e.gl);const s=this._lineProgram=await e.loadShaderProgramAsync("shaders/Line-Vertex.glsl","shaders/Line-Fragment.glsl"),o=e.gl;this._lineColorUniform=o.getUniformLocation(s,"color"),this._mvpMatrixUniform=o.getUniformLocation(s,"uMvpMatrix"),this._lineVertexBuffer=o.getAttribLocation(s,"aVertexPosition")}_updateUserCamera(t){const e=performance.now();this._userModeLastTick>0&&this._handleUserCameraKeys(e-this._userModeLastTick);const r=this._userModeLookDist,i=r*Math.cos(this._lookAtY),s=r*Math.sin(this._lookAtY);t.setCameraPosition(this._cameraX,this._cameraY,this._cameraZ),t.setLookAtPosition(this._cameraX+i*Math.sin(this._lookAtXZ),this._cameraY+s,this._cameraZ-i*Math.cos(this._lookAtXZ)),this._userModeLastTick=e}_updateAutoCamera(t){this._autoRestoreStartTime>0?this._getAutoRestorePosition():this._getAutoCameraPosition(),t.setCameraPosition(this._tempPt0[0],this._tempPt0[1],this._tempPt0[2]),t.setLookAtPosition(this._tempPt1[0],this._tempPt1[1],this._tempPt1[2])}_toggleCameraMode(){(this._userMode=!this._userMode)?this._startUserCamera():this._startAutoCamera()}_startUserCamera(){this._getAutoCameraPosition(),this._cameraX=this._tempPt0[0],this._cameraY=this._tempPt0[1],this._cameraZ=this._tempPt0[2];const t=this._tempPt1[0]-this._cameraX,e=this._tempPt1[1]-this._cameraY,r=-(this._tempPt1[2]-this._cameraZ),i=Math.sqrt(t*t+e*e+r*r);this._lookAtY=Math.asin(e/i),this._lookAtXZ=Math.atan2(t,r),this._userModeStartTime=performance.now()}_startAutoCamera(){const t=performance.now();this._autoRestoreStartTime=t,this._autoTimeOffset+=t-this._userModeStartTime,this._getAutoCameraPosition(),this._autoTimeOffset+=this._autoRestoreDuration;const e=this._userModeLookDist*Math.cos(this._lookAtY),r=this._userModeLookDist*Math.sin(this._lookAtY),i=this._cameraX+e*Math.sin(this._lookAtXZ),s=this._cameraY+r,o=this._cameraZ-e*Math.cos(this._lookAtXZ);this._restoreCameraSpline.set(0,this._cameraX,this._cameraY,this._cameraZ),this._restoreLookAtSpline.set(0,i,s,o),this._restoreCameraSpline.setv(1,this._tempPt0),this._restoreLookAtSpline.setv(1,this._tempPt1)}_handleUserCameraKeys(t){const e=this._keysDown,r=Math.PI/2-Math.PI/16,i=this._userMoveV*t,s=this._userScrlV*t,o=this._userLookV*t,a=this._userPntrV*t;this._pointerLocked&&(this._lookAtXZ+=this._pointerDx*a,this._lookAtY=Math.min(Math.max(this._lookAtY-this._pointerDy*a,-r),r)),e.has(KeyCodes.left)&&(this._lookAtXZ-=o),e.has(KeyCodes.right)&&(this._lookAtXZ+=o),e.has(KeyCodes.up)&&(this._lookAtY=Math.min(this._lookAtY+o,r)),e.has(KeyCodes.down)&&(this._lookAtY=Math.max(this._lookAtY-o,-r)),e.has(KeyCodes.space)&&(this._cameraY+=i),e.has(KeyCodes.shiftL)&&(this._cameraY-=i);const n=Math.cos(this._lookAtY),h=Math.sin(this._lookAtY),_=n*Math.sin(this._lookAtXZ),l=h,u=n*Math.cos(this._lookAtXZ);this._scrollWheel<0&&(this._cameraX+=s*_,this._cameraY+=s*l,this._cameraZ-=s*u),this._scrollWheel>0&&(this._cameraX-=s*_,this._cameraY-=s*l,this._cameraZ+=s*u),e.has(KeyCodes.w)&&(this._cameraX+=i*_,this._cameraY+=i*l,this._cameraZ-=i*u),e.has(KeyCodes.s)&&(this._cameraX-=i*_,this._cameraY-=i*l,this._cameraZ+=i*u)}_getAutoCameraPosition(){const t=this._autoDuration,e=(performance.now()-this._autoTimeOffset)%t/t;this._autoCameraSpline.interpolate(this._tempPt0,0,e),this._autoLookAtSpline.interpolate(this._tempPt1,0,e)}_getAutoRestorePosition(){const t=performance.now()-this._autoRestoreStartTime;t>this._autoRestoreDuration&&(this._autoRestoreStartTime=0);const e=Math.min(t/this._autoRestoreDuration,1);this._restoreCameraSpline.interpolate(this._tempPt0,0,e),this._restoreLookAtSpline.interpolate(this._tempPt1,0,e)}}class GroundTile{constructor(t,e,r,i,s,o){this.texture=t,this.indexCount=e,this.indexBuffer=r,this.vertexBuffer=i,this.texCoordBuffer=s,this.exits=o,this.normalBuffer=null}}class GroundModel extends Model{constructor(t){super(),this.gl=t,this.rows=-1,this.cols=-1,this._shader=null,this._tileSize=50,this._tiles=new Array,this._layout=new Array,this._tileIndexCount=0,this._tileIndexBuffer=null,this._tileVertexBuffer=null,this._tileTexCoordBuffer=null;const e=[0,0,0,50,0,0,50,0,50,0,0,50],r=[1,0,3,3,2,1];this._tileIndexCount=r.length,this._tileIndexBuffer=t.createBuffer(),this._tileVertexBuffer=t.createBuffer(),this._tileTexCoordBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this._tileVertexBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array(e),t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,this._tileTexCoordBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,1,1,1,1,0,0,0]),t.STATIC_DRAW),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this._tileIndexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint16Array(r),t.STATIC_DRAW)}isValidTile(t,e){return t>=0&&t<this.rows&&e>=0&&e<this.cols&&this._layout[t*this.cols+e]>=0}getTileCenterX(t){return this._tileSize*(t-.5*this.cols+.5)}getTileCenterZ(t){return this._tileSize*(t-.5*this.rows+.5)}canExitTile(t,e,r){if(r<0||r>=4||t<0||t>=this.rows||e<0||e>=this.cols)return!0;const i=this._layout[t*this.cols+e];return i<0||this._tiles[i].exits[r]}render(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++){const i=this._layout[e*this.cols+r];i>=0&&(t.saveMatrix(),t.translate(r*this._tileSize-this.cols*this._tileSize/2,0,e*this._tileSize-this.rows*this._tileSize/2),this._shader.render(t,this._tiles[i]),t.restoreMatrix())}}async configureAsync(t,e){this.rows=0|t.rows,this.cols=0|t.cols,this._layout=t.layout;const r=[],i=t.tiles;for(let i=0,s=t.tiles.length;i<s;i++){const s=t.tiles[i];r.push(e.getTextureAsync(s.texture))}r.push(e.getModelShaderAsync(t.shader));const s=await Promise.all(r),o=s.length-1;this._shader=s[o];for(let t=0;t<o;t++)this._tiles.push(new GroundTile(s[t],this._tileIndexCount,this._tileIndexBuffer,this._tileVertexBuffer,this._tileTexCoordBuffer,i[t].exits))}}const _EPSILON=1e-8;class Mtx4{static toInverseTransposeMat3(t,e){const r=e[0],i=e[1],s=e[2],o=e[3],a=e[4],n=e[5],h=e[6],_=e[7],l=e[8],u=e[9],f=e[10],c=e[11],d=e[12],m=e[13],A=e[14],x=e[15],M=r*n-i*a,p=r*h-s*a,g=r*_-o*a,R=i*h-s*n,T=i*_-o*n,y=s*_-o*h,v=l*m-u*d,B=l*A-f*d,w=l*x-c*d,E=u*A-f*m,b=u*x-c*m,P=f*x-c*A;let C=M*P-p*b+g*E+R*w-T*B+y*v;Math.abs(C)<_EPSILON||(t[0]=(n*P-h*b+_*E)/C,t[1]=(h*w-a*P-_*B)/C,t[2]=(a*b-n*w+_*v)/C,t[3]=(s*b-i*P-o*E)/C,t[4]=(r*P-s*w+o*B)/C,t[5]=(i*w-r*b-o*v)/C,t[6]=(m*y-A*T+x*R)/C,t[7]=(A*g-d*y-x*p)/C,t[8]=(d*T-m*g+x*M)/C)}static perspective(t,e,r,i,s){const o=1/Math.tan(e/2),a=1/(i-s);t[0]=o/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=(s+i)*a,t[11]=-1,t[12]=0,t[13]=0,t[14]=2*s*i*a,t[15]=0}static lookAt(t,e,r,i){let s=0,o=0,a=0,n=0,h=0,_=0,l=0,u=0,f=0,c=0;const d=e[0],m=e[1],A=e[2],x=i[0],M=i[1],p=i[2],g=r[0],R=r[1],T=r[2];Math.abs(d-g)<_EPSILON&&Math.abs(m-R)<_EPSILON&&Math.abs(A-T)<_EPSILON?Mtx4.identity(t):(l=d-g,u=m-R,f=A-T,c=1/Math.sqrt(l*l+u*u+f*f),l*=c,u*=c,f*=c,s=M*f-p*u,o=p*l-x*f,a=x*u-M*l,c=Math.sqrt(s*s+o*o+a*a),c?(c=1/c,s*=c,o*=c,a*=c):(s=0,o=0,a=0),n=u*a-f*o,h=f*s-l*a,_=l*o-u*s,c=Math.sqrt(n*n+h*h+_*_),c<_EPSILON?(n=0,h=0,_=0):(c=1/c,n*=c,h*=c,_*=c),t[0]=s,t[1]=n,t[2]=l,t[3]=0,t[4]=o,t[5]=h,t[6]=u,t[7]=0,t[8]=a,t[9]=_,t[10]=f,t[11]=0,t[12]=-(s*d+o*m+a*A),t[13]=-(n*d+h*m+_*A),t[14]=-(l*d+u*m+f*A),t[15]=1)}static rotate(t,e,r,i,s){let o=Math.sqrt(r*r+i*i+s*s);if(o<_EPSILON)return;o=1/o,r*=o,i*=o,s*=o;const a=Math.sin(e),n=Math.cos(e),h=1-n,_=t[0],l=t[1],u=t[2],f=t[3],c=t[4],d=t[5],m=t[6],A=t[7],x=t[8],M=t[9],p=t[10],g=t[11],R=r*r*h+n,T=i*r*h+s*a,y=s*r*h-i*a;t[0]=_*R+c*T+x*y,t[1]=l*R+d*T+M*y,t[2]=u*R+m*T+p*y,t[3]=f*R+A*T+g*y;const v=r*i*h-s*a,B=i*i*h+n,w=s*i*h+r*a;t[4]=_*v+c*B+x*w,t[5]=l*v+d*B+M*w,t[6]=u*v+m*B+p*w,t[7]=f*v+A*B+g*w;const E=r*s*h+i*a,b=i*s*h-r*a,P=s*s*h+n;t[8]=_*E+c*b+x*P,t[9]=l*E+d*b+M*P,t[10]=u*E+m*b+p*P,t[11]=f*E+A*b+g*P}static transform(t,e){const r=t[0],i=t[1],s=t[2],o=t[3],a=t[4],n=t[5],h=t[6],_=t[7],l=t[8],u=t[9],f=t[10],c=t[11],d=t[12],m=t[13],A=t[14],x=t[15];let M=e[0],p=e[1],g=e[2],R=e[3];t[0]=M*r+p*a+g*l+R*d,t[1]=M*i+p*n+g*u+R*m,t[2]=M*s+p*h+g*f+R*A,t[3]=M*o+p*_+g*c+R*x,M=e[4],p=e[5],g=e[6],R=e[7],t[4]=M*r+p*a+g*l+R*d,t[5]=M*i+p*n+g*u+R*m,t[6]=M*s+p*h+g*f+R*A,t[7]=M*o+p*_+g*c+R*x,M=e[8],p=e[9],g=e[10],R=e[11],t[8]=M*r+p*a+g*l+R*d,t[9]=M*i+p*n+g*u+R*m,t[10]=M*s+p*h+g*f+R*A,t[11]=M*o+p*_+g*c+R*x,M=e[12],p=e[13],g=e[14],R=e[15],t[12]=M*r+p*a+g*l+R*d,t[13]=M*i+p*n+g*u+R*m,t[14]=M*s+p*h+g*f+R*A,t[15]=M*o+p*_+g*c+R*x}static translate(t,e,r,i){t[12]+=e*t[0]+r*t[4]+i*t[8],t[13]+=e*t[1]+r*t[5]+i*t[9],t[14]+=e*t[2]+r*t[6]+i*t[10],t[15]+=e*t[3]+r*t[7]+i*t[11]}static scale(t,e,r,i){t[0]*=e,t[1]*=e,t[2]*=e,t[3]*=e,t[4]*=r,t[5]*=r,t[6]*=r,t[7]*=r,t[8]*=i,t[9]*=i,t[10]*=i,t[11]*=i}static copy(t,e){t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]}static identity(t){t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1}}class MultiQuadStripModel{constructor(){this.shader=null,this.parts=new Array}render(t){for(let e=0,r=this.parts.length;e<r;e++)this.shader.render(t,this.parts[e])}async configureAsync(t,e){const r=e.gl;let i=null;const s=[e.getModelShaderAsync(t.shader)];for(let o=0,a=t.parts.length;o<a;o++)this.parts.push(i=new MultiQuadStripModelPart(r)),s.push(i.configureAsync(t.parts[o],e));const o=await Promise.all(s);this.shader=o[0]}}class MultiQuadStripModelPart{constructor(t){this.texture=null,this.indexCount=0,this.indexBuffer=null,this.normalBuffer=null,this.vertexBuffer=null,this.texCoordBuffer=null,this.indexBuffer=t.createBuffer(),this.vertexBuffer=t.createBuffer(),this.texCoordBuffer=t.createBuffer()}async configureAsync(t,e){const r=t.coords.length/3|0,i=Math.floor(r/2)-1,s=new Float32Array(2*r),o=new Uint16Array(3*(r-2));let a=0;for(let t=0,e=s.length;t<e;t+=4){const e=a/i;s[t+0]=e,s[t+1]=0,s[t+2]=e,s[t+3]=1,a+=1}for(let t=0;t<i;t++)o[6*t+0]=2*t+0,o[6*t+1]=2*t+1,o[6*t+2]=2*t+2,o[6*t+3]=2*t+2,o[6*t+4]=2*t+1,o[6*t+5]=2*t+3;this.indexCount=o.length;const n=e.gl;n.bindBuffer(n.ARRAY_BUFFER,this.vertexBuffer),n.bufferData(n.ARRAY_BUFFER,new Float32Array(t.coords),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,this.texCoordBuffer),n.bufferData(n.ARRAY_BUFFER,s,n.STATIC_DRAW),n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer),n.bufferData(n.ELEMENT_ARRAY_BUFFER,o,n.STATIC_DRAW),this.texture=await e.getTextureAsync(t.texture)}}class WglRenderStateImpl{constructor(t,e,r){this.gl=t,this._basePjMatrix=e,this._baseMvMatrix=r,this._mvProjMatrix=new Float32Array(16),this._mvInvtMatrix=new Float32Array(9),this._lookAtInvtMatrix=new Float32Array(9),this._mvMatrix=new Float32Array(16),this._mvStack=new Array(this._mvMatrix),this._mvDepth=0,this._mvInvtDirty=!0,this._mvProjDirty=!0}modelViewToUniform4fv(t){this.gl.uniformMatrix4fv(t,!1,this._mvMatrix)}modelViewProjToUniform4fv(t){this._mvProjDirty&&(this._mvProjDirty=!1,Mtx4.copy(this._mvProjMatrix,this._basePjMatrix),Mtx4.transform(this._mvProjMatrix,this._mvMatrix)),this.gl.uniformMatrix4fv(t,!1,this._mvProjMatrix)}modelViewInvtToUniform3fv(t){this._mvInvtDirty&&(this._mvInvtDirty=!1,Mtx4.toInverseTransposeMat3(this._mvInvtMatrix,this._mvMatrix)),this.gl.uniformMatrix3fv(t,!1,this._mvInvtMatrix)}lookAtInvtToUniform3fv(t){this.gl.uniformMatrix3fv(t,!1,this._lookAtInvtMatrix)}saveMatrix(){this._mvDepth++,this._mvStack.length==this._mvDepth&&this._mvStack.push(new Float32Array(16));const t=this._mvStack[this._mvDepth];Mtx4.copy(t,this._mvMatrix),this._mvMatrix=t}restoreMatrix(){this._mvDepth>0?(this._mvProjDirty=!0,this._mvInvtDirty=!0,this._mvMatrix=this._mvStack[--this._mvDepth]):console.warn("WglRenderState save/restore mismatch")}rotate(t,e,r,i){this._mvProjDirty=!0,this._mvInvtDirty=!0,Mtx4.rotate(this._mvMatrix,t,e,r,i)}translate(t,e,r){this._mvProjDirty=!0,this._mvInvtDirty=!0,Mtx4.translate(this._mvMatrix,t,e,r)}scale(t,e,r){this._mvProjDirty=!0,this._mvInvtDirty=!0,Mtx4.scale(this._mvMatrix,t,e,r)}transform(t){this._mvProjDirty=!0,this._mvInvtDirty=!0,Mtx4.transform(this._mvMatrix,t)}setMatrix(t){this._mvProjDirty=!0,this._mvInvtDirty=!0,Mtx4.copy(this._mvMatrix,t)}_reset(){this._mvDepth>0&&console.warn("Resetting WglRenderState from an unclean state"),this._mvDepth=0,this._mvMatrix=this._mvStack[0],this._mvInvtDirty=!0,this._mvProjDirty=!0,Mtx4.copy(this._mvMatrix,this._baseMvMatrix),Mtx4.toInverseTransposeMat3(this._lookAtInvtMatrix,this._baseMvMatrix)}}class WglContainer{constructor(t){this._canvas=t,this._camera=new Float32Array([0,0,0]),this._lookAt=new Float32Array([0,0,1]),this._upward=new Float32Array([0,1,0]),this._baseMvMatrix=new Float32Array(16),this._basePjMatrix=new Float32Array(16),this._viewPortW=1,this._viewPortH=1,this._fovRadians=Math.PI/4,this._nearDist=.1,this._farDist=100,this._viewDirty=!1,this._projDirty=!1;const e=t.getContext("webgl");Mtx4.identity(this._basePjMatrix),Mtx4.identity(this._baseMvMatrix),e.enable(e.DEPTH_TEST),e.enable(e.CULL_FACE),e.enable(e.BLEND),e.cullFace(e.BACK),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.clearColor(0,0,0,1),this.state=new WglRenderStateImpl(e,this._basePjMatrix,this._baseMvMatrix),this.updateViewportSize()}updateViewportSize(){this._projDirty=!0,this._viewPortW=this._canvas.offsetWidth,this._viewPortH=this._canvas.offsetHeight,this._canvas.width=this._viewPortW,this._canvas.height=this._viewPortH}setPerspective(t,e,r){this._fovRadians=t,this._nearDist=e,this._farDist=r,this._projDirty=!0}setCameraPosition(t,e,r){this._camera[0]=t,this._camera[1]=e,this._camera[2]=r,this._viewDirty=!0}setLookAtPosition(t,e,r){this._lookAt[0]=t,this._lookAt[1]=e,this._lookAt[2]=r,this._viewDirty=!0}setUpwardVector(t,e,r){this._upward[0]=t,this._upward[1]=e,this._upward[2]=r,this._viewDirty=!0}beginRenderFrame(){const t=this.state,e=t.gl;this._projDirty&&(this._projDirty=!1,Mtx4.perspective(this._basePjMatrix,this._fovRadians,this._viewPortW/this._viewPortH,this._nearDist,this._farDist),e.viewport(0,0,this._viewPortW,this._viewPortH)),this._viewDirty&&(this._viewDirty=!1,Mtx4.lookAt(this._baseMvMatrix,this._camera,this._lookAt,this._upward)),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),t._reset()}}class RotateTransform extends Renderable{constructor(t,e,r){super(),this._renderable=t,this._ax=r[0],this._ay=r[0],this._az=r[0],this._angle=e*(Math.PI/180)}render(t){t.saveMatrix(),t.rotate(2*Math.PI*(Date.now()%5e3/5e3),this._ax,this._ay,this._az),this._renderable.render(t),t.restoreMatrix()}}class TranslateTransform extends Renderable{constructor(t,e){super(),this._renderable=t,this._x=e[0],this._y=e[1],this._z=e[2]}render(t){t.saveMatrix(),t.translate(this._x,this._y,this._z),this._renderable.render(t),t.restoreMatrix()}}class Vehicle extends Renderable{constructor(t,e){super(),this._model=t,this._ground=e,this._pos=new Float32Array(3),this._path=new Spline3(4),this._locations=new Float32Array(12),this._locationI=0,this._duration=3e3*Math.random()+1500|0,this._timeIndex=0,this._row=-1,this._col=-1,this._direction=4*Math.random()|0,this._angleXz=2*Math.PI*Math.random(),this._x=0,this._z=0,this._y=0;do{this._row=Math.floor(e.rows*Math.random()),this._col=Math.floor(e.cols*Math.random())}while(!e.isValidTile(this._row,this._col));let r=e.getTileCenterX(this._col),i=e.getTileCenterZ(this._row),s=10*Math.random()+3;this._locations[0]=r,this._locations[1]=s,this._locations[2]=i,this._locationI=1,this._x=r,this._y=s,this._z=i,this._nextLocation(),this._nextLocation(),this._nextLocation(),this._updatePath()}render(t){const e=Date.now()%this._duration/this._duration,r=Date.now()/this._duration|0;this._timeIndex!=r&&(this._timeIndex=r,this._nextLocation(),this._updatePath()),this._path.interpolate(this._pos,0,1/3+1/3*Math.min(e,1));const i=this._pos[0]-this._x,s=this._pos[2]-this._z;(Math.abs(i)>.1||Math.abs(s)>.1)&&(this._angleXz=Math.atan2(i,s),this._x=this._pos[0],this._z=this._pos[2]),t.saveMatrix(),t.translate(this._pos[0],this._pos[1],this._pos[2]),t.translate(1,1,1),t.rotate(this._angleXz,0,1,0),t.translate(-1,-1,-1),this._model.render(t),t.restoreMatrix()}_nextLocation(){const t=this._direction;do{this._direction=Vehicle.nextDirections[3*t+(3*Math.random()|0)]}while(!this._ground.canExitTile(this._row,this._col,this._direction));this._row+=Vehicle.nextRow[this._direction],this._col+=Vehicle.nextCol[this._direction];const e=Math.min(Math.max(this._y+10*Math.random()-5,3),50),r=3*this._locationI;this._locations[r+0]=this._ground.getTileCenterX(this._col),this._locations[r+1]=e,this._locations[r+2]=this._ground.getTileCenterZ(this._row),this._y=e,this._locationI=(this._locationI+1)%4}_updatePath(){for(let t=0;t<4;t++){const e=(this._locationI+t)%4*3;this._path.set(t,this._locations[e+0],this._locations[e+1],this._locations[e+2])}}}Vehicle.nextRow=[-1,0,1,0],Vehicle.nextCol=[0,1,0,-1],Vehicle.nextDirections=[0,1,3,0,1,2,1,2,3,0,2,3];class WorldModel extends Model{constructor(){super(...arguments),this._objects=new Array}render(t){for(let e=0,r=this._objects.length;e<r;e++)this._objects[e].render(t)}async configureAsync(t,e){const r=[],i=new Map;for(let s in t.models)r.push(this._loadModel(i,s,t.models[s],e));await Promise.all(r),this._parseObjects(i,t.objects),this._parseVehicles(i,t.vehicles)}async _loadModel(t,e,r,i){const s=await i.loadModelAsync(r);t.set(e,s)}_parseObjects(t,e){for(let r=0;r<e.length;r++){let i=e[r],s=this._getModelOrThrow(t,i.model);const o=i.transform;if("object"==typeof o)if(o instanceof Array)for(let t=0;t<o.length;t++)s=this._applyTransform(s,o[t]);else s=this._applyTransform(s,o);this._objects.push(s)}}_applyTransform(t,e){return e.translate?new TranslateTransform(t,e.translate):e.rotate?new RotateTransform(t,e.rotate,e.axis):t}_parseVehicles(t,e){const r=this._getModelOrThrow(t,"ground");for(let i=0;i<e.length;i++){const s=e[i],o=s.count||0,a=this._getModelOrThrow(t,s.model);for(let t=0;t<o;t++)this._objects.push(new Vehicle(a,r))}}_getModelOrThrow(t,e){const r=t.get(e)||null;if(!r)throw new Error(`No model with key=${e}`);return r}}class SkyModel{constructor(t){this.shader=null,this.texture=null,this.normalBuffer=null,this.indexCount=0,this.indexBuffer=t.createBuffer(),this.vertexBuffer=t.createBuffer(),this.texCoordBuffer=t.createBuffer()}render(t){this.shader.render(t,this)}async configureAsync(t,e){const r=e.gl,i=1e3,s=1/8,o=new Float32Array([0,1,1*s,1,1*s,0,0,0,1*s,1,.25,1,.25,0,1*s,0,.25,1,3*s,1,3*s,0,.25,0,3*s,1,.5,1,.5,0,3*s,0,.6875,1,.6875,0,.5625,0,.5625,1,.875,0,.75,0,.75,1,.875,1]),a=new Float32Array([-i,i,i,-i,i,-i,-i,-i,-i,-i,-i,i,-i,i,-i,i,i,-i,i,-i,-i,-i,-i,-i,i,i,-i,i,i,i,i,-i,i,i,-i,-i,i,i,i,-i,i,i,-i,-i,i,i,-i,i,-i,i,i,i,i,i,i,i,-i,-i,i,-i,-i,-i,i,-i,-i,-i,i,-i,-i,i,-i,i]),n=new Uint16Array([2,1,0,2,0,3,6,5,4,6,4,7,10,9,8,10,8,11,14,13,12,14,12,15,18,17,16,18,16,19,22,21,20,22,20,23]);this.indexCount=36,r.bindBuffer(r.ARRAY_BUFFER,this.vertexBuffer),r.bufferData(r.ARRAY_BUFFER,a,r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,this.texCoordBuffer),r.bufferData(r.ARRAY_BUFFER,o,r.STATIC_DRAW),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,this.indexBuffer),r.bufferData(r.ELEMENT_ARRAY_BUFFER,n,r.STATIC_DRAW);const[h,_]=await Promise.all([e.getModelShaderAsync(t.shader),e.getTextureAsync(t.texture)]);this.shader=h,this.texture=_}}class RawVerticesModel{constructor(t){this.indexCount=0,this.texture=null,this.shader=null,this.indexBuffer=t.createBuffer(),this.vertexBuffer=t.createBuffer(),this.normalBuffer=t.createBuffer(),this.texCoordBuffer=t.createBuffer()}render(t){this.shader.render(t,this)}async configureAsync(t,e){this.indexCount=t.indicies.length;const r=e.gl;this._buildIndexBuffer(r,this.indexBuffer,t.indicies),this._buildArrayBuffer(r,this.vertexBuffer,t.vertices),this._buildArrayBuffer(r,this.normalBuffer,t.normals),this._buildArrayBuffer(r,this.texCoordBuffer,t.texCoords);const[i,s]=await Promise.all([e.getTextureAsync(t.texture),e.getModelShaderAsync(t.shader)]);this.texture=i,this.shader=s}_buildArrayBuffer(t,e,r){t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,new Float32Array(r),t.STATIC_DRAW)}_buildIndexBuffer(t,e,r){const i=t.ELEMENT_ARRAY_BUFFER;t.bindBuffer(i,e),t.bufferData(i,new Uint16Array(r),t.STATIC_DRAW)}}class DiffuseShader{constructor(t,e){this._shaderProgram=e,this._vertexBufferAttr=t.getAttribLocation(e,"aVertexPosition"),this._normalBufferAttr=t.getAttribLocation(e,"aVertexNormal"),this._texCoordBufferAttr=t.getAttribLocation(e,"aTextureCoord"),this._samplerUniform=t.getUniformLocation(e,"uSampler"),this._modelViewPrjUniform=t.getUniformLocation(e,"uModelViewPrj"),this._lookAtInvtUniform=t.getUniformLocation(e,"uLookAtInvT"),this._normalInvtUniform=t.getUniformLocation(e,"uNormalInvT"),this._ambientColorUniform=t.getUniformLocation(e,"uAmbientColor"),this._directionalColorUniform=t.getUniformLocation(e,"uDirectionalColor"),this._directionalVectorUniform=t.getUniformLocation(e,"uDirectionalVector")}render(t,e){const r=t.gl;r.useProgram(this._shaderProgram),r.enableVertexAttribArray(this._vertexBufferAttr),r.enableVertexAttribArray(this._normalBufferAttr),r.enableVertexAttribArray(this._texCoordBufferAttr),r.bindBuffer(r.ARRAY_BUFFER,e.vertexBuffer),r.vertexAttribPointer(this._vertexBufferAttr,3,r.FLOAT,!1,0,0),r.bindBuffer(r.ARRAY_BUFFER,e.normalBuffer),r.vertexAttribPointer(this._normalBufferAttr,3,r.FLOAT,!1,0,0),r.bindBuffer(r.ARRAY_BUFFER,e.texCoordBuffer),r.vertexAttribPointer(this._texCoordBufferAttr,2,r.FLOAT,!1,0,0),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,e.texture),r.uniform1i(this._samplerUniform,0);const i=Date.now()%2e4/2e4,s=2*Math.PI*i;r.uniform3f(this._ambientColorUniform,.3,.3,.3),r.uniform3f(this._directionalVectorUniform,Math.cos(s),0,Math.sin(s)),r.uniform3f(this._directionalColorUniform,.8,.8,.8),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e.indexBuffer),t.modelViewProjToUniform4fv(this._modelViewPrjUniform),t.modelViewInvtToUniform3fv(this._normalInvtUniform),t.lookAtInvtToUniform3fv(this._lookAtInvtUniform),r.drawElements(r.TRIANGLES,e.indexCount,r.UNSIGNED_SHORT,0),r.disableVertexAttribArray(this._vertexBufferAttr),r.disableVertexAttribArray(this._normalBufferAttr),r.disableVertexAttribArray(this._texCoordBufferAttr)}}class FlatShader{constructor(t,e){this._shaderProgram=e,t.useProgram(e),this._vertexBufferAttr=t.getAttribLocation(e,"aVertexPosition"),this._texCoordBufferAttr=t.getAttribLocation(e,"aTextureCoord"),this._samplerUniform=t.getUniformLocation(e,"uSampler"),this._mvpMatrixUniform=t.getUniformLocation(e,"uMvpMatrix")}render(t,e){const r=t.gl;r.useProgram(this._shaderProgram),r.enableVertexAttribArray(this._texCoordBufferAttr),r.enableVertexAttribArray(this._vertexBufferAttr),r.bindBuffer(r.ARRAY_BUFFER,e.vertexBuffer),r.vertexAttribPointer(this._vertexBufferAttr,3,r.FLOAT,!1,0,0),r.bindBuffer(r.ARRAY_BUFFER,e.texCoordBuffer),r.vertexAttribPointer(this._texCoordBufferAttr,2,r.FLOAT,!1,0,0),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,e.texture),r.uniform1i(this._samplerUniform,0),t.modelViewProjToUniform4fv(this._mvpMatrixUniform),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e.indexBuffer),r.drawElements(r.TRIANGLES,e.indexCount,r.UNSIGNED_SHORT,0),r.disableVertexAttribArray(this._texCoordBufferAttr),r.disableVertexAttribArray(this._vertexBufferAttr)}}class BumpShader{constructor(t,e){this._shaderProgram=e,this._vertexBufferAttr=t.getAttribLocation(e,"aVertexPosition"),this._normalBufferAttr=t.getAttribLocation(e,"aVertexNormal"),this._tangentBufferAttr=t.getAttribLocation(e,"aVertexTangent"),this._texCoordBufferAttr=t.getAttribLocation(e,"aTextureCoord"),this._samplerUniform=t.getUniformLocation(e,"tex_diffuse"),this._bumpMapUniform=t.getUniformLocation(e,"tex_bumpMap"),this._modelViewUniform=t.getUniformLocation(e,"uModelView"),this._modelViewPrjUniform=t.getUniformLocation(e,"uModelViewPrj"),this._lookAtInvtUniform=t.getUniformLocation(e,"uLookAtInvT"),this._normalInvtUniform=t.getUniformLocation(e,"uNormalInvT"),this._ambientColorUniform=t.getUniformLocation(e,"uAmbientColor"),this._directionalColorUniform=t.getUniformLocation(e,"uDirectionalColor"),this._directionalVectorUniform=t.getUniformLocation(e,"uDirectionalVector")}render(t,e){const r=t.gl;r.useProgram(this._shaderProgram),r.enableVertexAttribArray(this._vertexBufferAttr),r.enableVertexAttribArray(this._normalBufferAttr),r.enableVertexAttribArray(this._tangentBufferAttr),r.enableVertexAttribArray(this._texCoordBufferAttr),r.bindBuffer(r.ARRAY_BUFFER,e.vertexBuffer),r.vertexAttribPointer(this._vertexBufferAttr,3,r.FLOAT,!1,0,0),r.bindBuffer(r.ARRAY_BUFFER,e.normalBuffer),r.vertexAttribPointer(this._normalBufferAttr,3,r.FLOAT,!1,0,0),r.bindBuffer(r.ARRAY_BUFFER,e.tangentBuffer),r.vertexAttribPointer(this._tangentBufferAttr,3,r.FLOAT,!1,0,0),r.bindBuffer(r.ARRAY_BUFFER,e.texCoordBuffer),r.vertexAttribPointer(this._texCoordBufferAttr,2,r.FLOAT,!1,0,0),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,e.texture),r.uniform1i(this._samplerUniform,0),r.activeTexture(r.TEXTURE1),r.bindTexture(r.TEXTURE_2D,e.bumpMap),r.uniform1i(this._bumpMapUniform,1);const i=Date.now()%2e4/2e4,s=2*Math.PI*i;r.uniform3f(this._ambientColorUniform,.3,.3,.3),r.uniform3f(this._directionalVectorUniform,Math.cos(s),0,Math.sin(s)),r.uniform3f(this._directionalColorUniform,.8,.8,.8),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e.indexBuffer),t.modelViewProjToUniform4fv(this._modelViewPrjUniform),t.modelViewInvtToUniform3fv(this._normalInvtUniform),t.lookAtInvtToUniform3fv(this._lookAtInvtUniform),r.drawElements(r.TRIANGLES,e.indexCount,r.UNSIGNED_SHORT,0),r.disableVertexAttribArray(this._vertexBufferAttr),r.disableVertexAttribArray(this._normalBufferAttr),r.disableVertexAttribArray(this._tangentBufferAttr),r.disableVertexAttribArray(this._texCoordBufferAttr)}}class Program{constructor(t,e){this._canvas=t,this._loader=e,this._cameraModel=null,this._worldModel=null,this._frameTimer=-1,this._initialized=!1,this._updateFrame=()=>{this._cameraModel.updateCamera(this._container),this._container.beginRenderFrame();const t=this._container.state;t.saveMatrix(),this._worldModel.render(t),this._cameraModel.render(t),t.restoreMatrix(),this._frameTimer=requestAnimationFrame(this._updateFrame)},this._handleResize=()=>{this._container.updateViewportSize(),this._initialized&&this._queueRender()};const r=this._container=new WglContainer(this._canvas);r.setUpwardVector(0,1,0),r.setLookAtPosition(0,0,0),r.setPerspective(Math.PI/4,1,2e3),this._res=new ResourceLoader(r.state.gl),window.onresize=this._handleResize}async load(){const t=this._res;t.addModelType("world",WorldModel),t.addModelType("sky",SkyModel),t.addModelType("camera",CameraModel),t.addModelType("ground",GroundModel),t.addModelType("building",BuildingModel),t.addModelType("rawVertices",RawVerticesModel),t.addModelType("multiQuadStrip",MultiQuadStripModel),await Promise.all([t.loadShader("diffuse","Diff",DiffuseShader),t.loadShader("flat","Flat",FlatShader),t.loadShader("bump","Bump",BumpShader)]);const[e,r]=await Promise.all([t.loadModelAsync("models/World.json"),t.loadModelAsync("models/Camera.json")]);this._worldModel=e,this._cameraModel=r,r.bindInputListeners(this._canvas),this._loader&&this._loader.parentElement.removeChild(this._loader),this._initialized=!0,this._queueRender()}_queueRender(){this._frameTimer<0&&(this._frameTimer=requestAnimationFrame(this._updateFrame))}}function startup(){const t=document.getElementById("about");t.addEventListener("click",()=>t.toggleAttribute("data-active")),new Program(document.getElementById("content"),document.getElementById("loader")).load()}