function throwIfNull(t,e){if(null==t)throw new Error("Argument cannot be null: "+e);return t}class ModelView{constructor(t){this.gl=t,throwIfNull(t,"gl"),this.pjMatrix=mat4.create(),this.mvMatrix=mat4.create(),this.keysDown=new Int32Array(128),this.pointerDx=0,this.pointerDy=0,this.pointerLocked=!1,this.scrollWheel=0,this._canvas=document.getElementById("content"),this._invTpMv=mat3.create(),this._mvStack=[this.mvMatrix],this._mvDepth=0;const e=t=>{this.pointerDx=t.movementX,this.pointerDy=t.movementY};document.addEventListener("pointerlockchange",t=>{this.pointerLocked=document.pointerLockElement===this._canvas||document.mozPointerLockElement===this._canvas,console.log(`pointerlockchange: ${this.pointerLocked}`),this.pointerLocked?document.addEventListener("pointermove",e,!1):document.removeEventListener("pointermove",e,!1)},!1),this._canvas.addEventListener("wheel",t=>(console.log(`mousewheel: ${t.deltaY}, ${t.deltaMode}`),this.scrollWheel=Math.max(-1,Math.min(1,t.deltaY)),!1),!1),document.addEventListener("keydown",t=>{const e=t.keyCode;e<this.keysDown.length&&(this.keysDown[e]=1)},!1),document.addEventListener("keyup",t=>{const e=t.keyCode;e<this.keysDown.length&&(this.keysDown[e]=0)},!1)}finishFrame(){this.pointerDx=0,this.pointerDy=0,this.scrollWheel=0}saveMvMatrix(){this._mvDepth++,this._mvStack.length==this._mvDepth&&this._mvStack.push(mat4.create()),this.mvMatrix=mat4.set(this.mvMatrix,this._mvStack[this._mvDepth])}restoreMvMatrix(){this.mvMatrix=this._mvStack[--this._mvDepth]}getInverseTransposeMvMatrix(){return mat4.toInverseMat3(this.mvMatrix,this._invTpMv),mat3.transpose(this._invTpMv)}}class Renderable{}class ModelRenderer{}class ResourceLoader{constructor(t){this.gl=t,this._fshaders=new Map,this._vshaders=new Map,this._textures=new Map,this._renderers=new Map,this._modelTypes=new Map,throwIfNull(t,"gl")}getModelType(t){const e=this._modelTypes.get(t);if(!e)throw new Error("Unknown model type: "+t);return e}addModelType(t,e){this._modelTypes.set(t,e)}getModelShaderAsync(t){const e=this._renderers.get(t);if(!e)throw new Error("Unknown renderer "+t);return e}addModelShader(t,e){this._renderers.set(t,e instanceof Promise?e:Promise.resolve(e))}createShaderProgramAsync(t,e){const r=this.gl;return Promise.all([this.getVertexShaderAsync(t),this.getFragmentShaderAsync(e)]).then(i=>{const s=r.createProgram();if(r.attachShader(s,i[0]),r.attachShader(s,i[1]),r.linkProgram(s),!r.getProgramParameter(s,r.LINK_STATUS))throw new Error(`Could not link shaders '${t}' and '${e}'`);return s})}getFragmentShaderAsync(t){return this._getShader(t,this.gl.FRAGMENT_SHADER,this._fshaders)}getVertexShaderAsync(t){return this._getShader(t,this.gl.VERTEX_SHADER,this._vshaders)}getTextureAsync(t){let e=this._textures.get(t);return null==e&&(e=this._loadTexture(t),this._textures.set(t,e)),e}_getShader(t,e,r){let i=r.get(t);return null==i&&(i=this._loadShader(t,e),r.set(t,i)),i}_loadTexture(t){return new Promise((e,r)=>{const i=new Image,s=this.gl.createTexture();i.onerror=()=>{r(new Error("Could not load image "+t))},i.onload=()=>{const t=this.gl;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!0),t.bindTexture(t.TEXTURE_2D,s),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,i),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.generateMipmap(t.TEXTURE_2D),t.bindTexture(t.TEXTURE_2D,null),e(s)},i.src=t})}_loadShader(t,e){return fetch(t).then(t=>t.text()).then(t=>{const r=this.gl,i=r.createShader(e);if(r.shaderSource(i,t),r.compileShader(i),!r.getShaderParameter(i,r.COMPILE_STATUS))throw new Error(r.getShaderInfoLog(i));return i})}}class Model extends Renderable{static loadAsync(t,e){return fetch(t).then(t=>t.json()).then(t=>this.parseAsync(t,e)).catch(e=>{throw console.error(`Could not load ${t}`,e),e})}static parseAsync(t,e){const r=new(e.getModelType(t.type))(e.gl);return r.configureAsync(t,e).then(()=>r)}}class BuildingModel extends Model{constructor(t){super(),this._levels=new Array}render(t){for(let e=0,r=this._levels.length;e<r;e++){const r=this._levels[e];r.shader.render(t,r)}}configureAsync(t,e){const r=e.gl,i=[],s=t.angleCount,o=this._createIndexBuffer(r,s),n=this._createTexCoordBuffer(r,s);let a=0,h=[];h.push(this._createVertexRingCoords(s,t.base,0));for(let e=0,r=t.levels.length;e<r;e++){const r=t.levels[e];a+=r.height,h.push(this._createVertexRingCoords(s,r.r,a))}const l=[];l.push(this._createNormalRingCoords(s,h[0],h[0],h[1]));for(let t=1,e=h.length-1;t<e;t++)l.push(this._createNormalRingCoords(s,h[t-1],h[t],h[t+1]));l.push(this._createNormalRingCoords(s,h[h.length-2],h[h.length-1],h[h.length-1]));for(let a=0,_=t.levels.length;a<_;a++){const _=new BuildingLevel(this._createPointBuffer(r,s,h[a+0],h[a+1]),this._createPointBuffer(r,s,l[a+0],l[a+1]),n,o,6*s);i.push(_.configureAsync(t.levels[a],e)),this._levels.push(_)}return Promise.all(i)}_createVertexRingCoords(t,e,r){const i=new Float32Array(3*t+3);let s=0,o=0;for(let n=0;n<e.length;n+=2){const a=e[n+0],h=e[n+1];for(let e=0;e<h;e++){const e=2*Math.PI*(o/t);i[s+0]=a*Math.cos(e),i[s+1]=r,i[s+2]=a*Math.sin(e),s+=3,o+=1}}const n=e[0],a=2*Math.PI*(o/t);return i[s+0]=n*Math.cos(a),i[s+1]=r,i[s+2]=n*Math.sin(a),i}_createNormalRingCoords(t,e,r,i){const s=new Float32Array(3*t+3);this._calculateNormal(s,t-2,0,1,e,r,i);for(let o=1;o<t;o++)this._calculateNormal(s,o-1,o,o+1,e,r,i);return this._calculateNormal(s,t-1,t+0,1,e,r,i),s}_calculateNormal(t,e,r,i,s,o,n){this._addCrossProd3(t,r,o,r,n,r,o,i),this._addCrossProd3(t,r,o,r,o,i,s,r),this._addCrossProd3(t,r,o,r,s,r,o,e),this._addCrossProd3(t,r,o,r,o,e,n,r),this._normalize3(t,r)}_addCrossProd3(t,e,r,i,s,o,n,a){const h=s[3*o+0]-r[3*i+0],l=s[3*o+1]-r[3*i+1],_=s[3*o+2]-r[3*i+2],c=n[3*a+0]-r[3*i+0],d=n[3*a+1]-r[3*i+1],u=n[3*a+2]-r[3*i+2];t[3*e+0]+=l*u-_*d,t[3*e+1]+=-h*u+_*c,t[3*e+2]+=h*d-l*c}_normalize3(t,e){const r=t[3*e+0],i=t[3*e+1],s=t[3*e+2],o=Math.sqrt(r*r+i*i+s*s);o>0&&(t[3*e+0]=r/o,t[3*e+1]=i/o,t[3*e+2]=s/o)}_createPointBuffer(t,e,r,i){const s=t.createBuffer(),o=3*e+3;return t.bindBuffer(t.ARRAY_BUFFER,s),t.bufferData(t.ARRAY_BUFFER,8*o,t.STATIC_DRAW),t.bufferSubData(t.ARRAY_BUFFER,0,r),t.bufferSubData(t.ARRAY_BUFFER,4*o,i),s}_createIndexBuffer(t,e){const r=t.createBuffer(),i=new Uint16Array(6*e);for(let t=0;t<e;t++)i[6*t+0]=t,i[6*t+1]=t+(e+1),i[6*t+2]=t+(e+1)+1,i[6*t+3]=t,i[6*t+4]=t+(e+1)+1,i[6*t+5]=t+1;return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,r),t.bufferData(t.ELEMENT_ARRAY_BUFFER,i,t.STATIC_DRAW),r}_createTexCoordBuffer(t,e){const r=new Float32Array(4*e+4);this._populateTexCoordRing(r,0,e,0),this._populateTexCoordRing(r,2*(e+1),e,1);const i=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,i),t.bufferData(t.ARRAY_BUFFER,r,t.STATIC_DRAW),i}_populateTexCoordRing(t,e,r,i){let s=0;for(let o=e,n=e+2*r;o<=n;o+=2)t[o+0]=s/r,t[o+1]=i,s+=1}}class BuildingLevel{constructor(t,e,r,i,s){this.vertexBuffer=t,this.normalBuffer=e,this.texCoordBuffer=r,this.indexBuffer=i,this.indexCount=s,this.shader=null,this.texture=null}configureAsync(t,e){return Promise.all([e.getModelShaderAsync(t.shader),e.getTextureAsync(t.texture)]).then(t=>{this.shader=t[0],this.texture=t[1]})}}class Spline3{constructor(t){this._count=t,this._tempV4=new Float32Array(4),this._tempM4=new Float32Array(16),this._points=new Float32Array(3*this._count),this._tangents=new Float32Array(3*this._count)}get count(){return this._count}getX(t){return this._points[3*t+0]}getY(t){return this._points[3*t+1]}getZ(t){return this._points[3*t+0]}set(t,e,r,i){const s=3*t,o=this._points;o[s+0]=e,o[s+1]=r,o[s+2]=i,this._recalculateTangent(Math.max(t-1,0)),this._recalculateTangent(Math.min(t+1,this._count-1))}createBuffer(t){const e=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,this._points,t.STATIC_DRAW),e}interpolate(t,e,r){const i=this._points,s=Math.min(Math.max(r,0),1)*(this._count-1),o=0|s,n=s-o;if(n<=0)return void V3_copy_V3(t,e,i,o);if(n>=1)return void V3_copy_V3(t,e,i,o+1);const a=this._tempV4;a[0]=n*n*n,a[1]=n*n,a[2]=n,a[3]=1;const h=3*o,l=this._tangents,_=this._tempM4,c=Spline3._hermite;_[0]=i[h+0],_[1]=l[h+0],_[2]=i[h+3],_[3]=l[h+3],_[4]=i[h+1],_[5]=l[h+1],_[6]=i[h+4],_[7]=l[h+4],_[8]=i[h+2],_[9]=l[h+2],_[10]=i[h+5],_[11]=l[h+5],_[12]=1,_[13]=1,_[14]=1,_[15]=1,M4_mul_V4(a,0,c,a,0),M4_mul_V4(a,0,_,a,0),V3_copy_V3(t,e,a,0)}_recalculateTangent(t){const e=this._points,r=this._tangents,i=Math.max(t-1,0);V3_sub_V3(r,t,e,Math.min(t+1,this._count-1),e,i),V3_mul_S1(r,t,r,t,.5)}}Spline3._hermite=new Float32Array([2,-3,0,1,1,-2,1,0,-2,3,0,0,1,-1,0,0]);const KeyCodes={shift:16,space:32,pageUp:33,pageDown:34,left:37,up:38,right:39,down:40,a:65,c:67,e:69,q:81,w:87,s:83,d:68,x:88,z:90};class CameraModel extends Model{constructor(){super(),this._cameraX=0,this._cameraY=20,this._cameraZ=30,this._lookAtY=0,this._lookAtXZ=0,this._cWasDown=!1,this._userCamera=!1,this._lineProgram=null,this._lineProgramVertexBuffer=-1,this._pjMatrixUniform=null,this._mvMatrixUniform=null,this._colorUniform=null,this._cameraBuffer=null,this._lookAtBuffer=null,this._cameraSpline=null,this._lookAtSpline=null,this._cameraValue=new Float32Array(3),this._lookAtValue=new Float32Array(3),CameraModel.instance=this}render(t){const e=t.keysDown;!this._cWasDown&&e[KeyCodes.c]&&(this._userCamera=!this._userCamera),this._cWasDown=!!e[KeyCodes.c],this._userCamera&&this._handleKeys(t),this._cameraToCtm(t.mvMatrix)}configureAsync(t,e){const r=t.points,i=r.length/6|0;this._cameraSpline=new Spline3(i),this._lookAtSpline=new Spline3(i);for(let t=0,e=0;t<r.length;t+=6,e++)this._cameraSpline.set(e,r[t+0],r[t+1],r[t+2]),this._lookAtSpline.set(e,r[t+3],r[t+4],r[t+5]);return this._cameraBuffer=this._cameraSpline.createBuffer(e.gl),this._lookAtBuffer=this._lookAtSpline.createBuffer(e.gl),e.createShaderProgramAsync("shaders/Line-Vertex.glsl","shaders/Line-Fragment.glsl").then(t=>{const r=e.gl;this._lineProgram=t,this._colorUniform=r.getUniformLocation(t,"color"),this._pjMatrixUniform=r.getUniformLocation(t,"uPjMatrix"),this._mvMatrixUniform=r.getUniformLocation(t,"uMvMatrix"),this._lineProgramVertexBuffer=r.getAttribLocation(t,"aVertexPosition")})}_cameraToCtm(t){if(this._userCamera)mat4.lookAt([this._cameraX,this._cameraY,this._cameraZ],[this._cameraX+20*Math.cos(this._lookAtY)*Math.sin(this._lookAtXZ),this._cameraY+20*Math.sin(this._lookAtY),this._cameraZ-20*Math.cos(this._lookAtY)*Math.cos(this._lookAtXZ)],[0,1,0],t);else{const e=Date.now()%2e5/2e5;this._cameraSpline.interpolate(this._cameraValue,0,e),this._lookAtSpline.interpolate(this._lookAtValue,0,e),mat4.lookAt(this._cameraValue,this._lookAtValue,[0,1,0],t)}}_handleKeys(t){const e=t.keysDown;t.pointerLocked&&(this._lookAtXZ+=.003*t.pointerDx,this._lookAtY=Math.min(Math.max(this._lookAtY-.003*t.pointerDy,-(Math.PI/2-Math.PI/16)),Math.PI/2-Math.PI/16)),e[KeyCodes.left]&&(this._lookAtXZ-=.07),e[KeyCodes.right]&&(this._lookAtXZ+=.07),e[KeyCodes.up]&&(this._lookAtY=Math.min(this._lookAtY+.07,Math.PI/2-Math.PI/16)),e[KeyCodes.down]&&(this._lookAtY=Math.max(this._lookAtY-.07,-(Math.PI/2-Math.PI/16))),e[KeyCodes.space]&&(this._cameraY+=1.5),e[KeyCodes.shift]&&(this._cameraY-=1.5),t.scrollWheel<0&&(this._cameraX+=7.5*Math.cos(this._lookAtY)*Math.sin(this._lookAtXZ),this._cameraY+=7.5*Math.sin(this._lookAtY),this._cameraZ-=7.5*Math.cos(this._lookAtY)*Math.cos(this._lookAtXZ)),t.scrollWheel>0&&(this._cameraX-=7.5*Math.cos(this._lookAtY)*Math.sin(this._lookAtXZ),this._cameraY-=7.5*Math.sin(this._lookAtY),this._cameraZ+=7.5*Math.cos(this._lookAtY)*Math.cos(this._lookAtXZ)),e[KeyCodes.w]&&(this._cameraX+=1.5*Math.cos(this._lookAtY)*Math.sin(this._lookAtXZ),this._cameraY+=1.5*Math.sin(this._lookAtY),this._cameraZ-=1.5*Math.cos(this._lookAtY)*Math.cos(this._lookAtXZ)),e[KeyCodes.s]&&(this._cameraX-=1.5*Math.cos(this._lookAtY)*Math.sin(this._lookAtXZ),this._cameraY-=1.5*Math.sin(this._lookAtY),this._cameraZ+=1.5*Math.cos(this._lookAtY)*Math.cos(this._lookAtXZ))}}CameraModel.instance=null;class DiffuseShader extends ModelRenderer{constructor(t,e,r){super(),this._shaderProgram=e,t.useProgram(e),this._vertexBufferAttr=t.getAttribLocation(e,"aVertexPosition"),this._normalBufferAttr=t.getAttribLocation(e,"aVertexNormal"),this._texCoordBufferAttr=t.getAttribLocation(e,"aTextureCoord"),this._pMatrixUniform=t.getUniformLocation(e,"uPMatrix"),this._mvMatrixUniform=t.getUniformLocation(e,"uMVMatrix"),this._nMatrixUniform=t.getUniformLocation(e,"uNMatrix"),this._samplerUniform=t.getUniformLocation(e,"uSampler"),this._useLightingUniform=t.getUniformLocation(e,"uUseLighting"),this._ambientColorUniform=t.getUniformLocation(e,"uAmbientColor"),this._lightingDirectionUniform=t.getUniformLocation(e,"uLightingDirection"),this._directionalColorUniform=t.getUniformLocation(e,"uDirectionalColor"),this._normalProgram=r,t.useProgram(r),this._normal_pMatrixUniform=t.getUniformLocation(r,"uPMatrix"),this._normal_mvMatrixUniform=t.getUniformLocation(r,"uMVMatrix"),this._normal_vertexBufferAttr=t.getAttribLocation(r,"aVertexPosition"),this._normal_normalBufferAttr=t.getAttribLocation(r,"aVertexNormal")}render(t,e){const r=t.gl;r.useProgram(this._shaderProgram),r.enableVertexAttribArray(this._vertexBufferAttr),r.enableVertexAttribArray(this._normalBufferAttr),r.enableVertexAttribArray(this._texCoordBufferAttr),r.bindBuffer(r.ARRAY_BUFFER,e.vertexBuffer),r.vertexAttribPointer(this._vertexBufferAttr,3,r.FLOAT,!1,0,0),r.bindBuffer(r.ARRAY_BUFFER,e.normalBuffer),r.vertexAttribPointer(this._normalBufferAttr,3,r.FLOAT,!1,0,0),r.bindBuffer(r.ARRAY_BUFFER,e.texCoordBuffer),r.vertexAttribPointer(this._texCoordBufferAttr,2,r.FLOAT,!1,0,0),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,e.texture),r.uniform1i(this._samplerUniform,0),r.uniform1i(this._useLightingUniform,1),r.uniform3f(this._ambientColorUniform,.3,.3,.3);const i=vec3.create();vec3.normalize([1,-1,0],i),vec3.scale(i,-1);const s=mat4.create();CameraModel.instance._cameraToCtm(s),mat4.inverse(s),mat4.transpose(s),mat4.multiplyVec3(s,i),r.uniform3fv(this._lightingDirectionUniform,i),r.uniform3f(this._directionalColorUniform,.9,.9,.9),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e.indexBuffer),r.uniformMatrix4fv(this._pMatrixUniform,!1,t.pjMatrix),r.uniformMatrix4fv(this._mvMatrixUniform,!1,t.mvMatrix);const o=mat3.create();mat4.toInverseMat3(t.mvMatrix,o),mat3.transpose(o),r.uniformMatrix3fv(this._nMatrixUniform,!1,o),r.drawElements(r.TRIANGLES,e.indexCount,r.UNSIGNED_SHORT,0),r.disableVertexAttribArray(this._vertexBufferAttr),r.disableVertexAttribArray(this._normalBufferAttr),r.disableVertexAttribArray(this._texCoordBufferAttr)}}class FlatShader extends ModelRenderer{constructor(t,e){super(),this._shaderProgram=e,t.useProgram(e),this._vertexBufferAttr=t.getAttribLocation(e,"aVertexPosition"),this._texCoordBufferAttr=t.getAttribLocation(e,"aTextureCoord"),this._samplerUniform=t.getUniformLocation(e,"uSampler"),this._pjMatrixUniform=t.getUniformLocation(e,"uPjMatrix"),this._mvMatrixUniform=t.getUniformLocation(e,"uMvMatrix")}render(t,e){const r=t.gl;r.useProgram(this._shaderProgram),r.enableVertexAttribArray(this._texCoordBufferAttr),r.enableVertexAttribArray(this._vertexBufferAttr),r.bindBuffer(r.ARRAY_BUFFER,e.vertexBuffer),r.vertexAttribPointer(this._vertexBufferAttr,3,r.FLOAT,!1,0,0),r.bindBuffer(r.ARRAY_BUFFER,e.texCoordBuffer),r.vertexAttribPointer(this._texCoordBufferAttr,2,r.FLOAT,!1,0,0),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,e.texture),r.uniform1i(this._samplerUniform,0),r.uniformMatrix4fv(this._pjMatrixUniform,!1,t.pjMatrix),r.uniformMatrix4fv(this._mvMatrixUniform,!1,t.mvMatrix),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e.indexBuffer),r.drawElements(r.TRIANGLES,e.indexCount,r.UNSIGNED_SHORT,0),r.disableVertexAttribArray(this._texCoordBufferAttr),r.disableVertexAttribArray(this._vertexBufferAttr)}}class GroundTile{constructor(t,e,r,i,s,o){this.texture=t,this.indexCount=e,this.indexBuffer=r,this.vertexBuffer=i,this.texCoordBuffer=s,this.exits=o}}class GroundModel extends Model{constructor(t){super(),this.gl=t,this.rows=-1,this.cols=-1,this._shader=null,this._tileSize=50,this._tiles=new Array,this._layout=new Array,this._tempVec=[0,0,0],this._tileIndexCount=0,this._tileIndexBuffer=null,this._tileVertexBuffer=null,this._tileTexCoordBuffer=null;const e=[0,0,0,50,0,0,50,0,50,0,0,50],r=[1,0,3,3,2,1];this._tileIndexCount=r.length,this._tileIndexBuffer=t.createBuffer(),this._tileVertexBuffer=t.createBuffer(),this._tileTexCoordBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this._tileVertexBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array(e),t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,this._tileTexCoordBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,1,1,1,1,0,0,0]),t.STATIC_DRAW),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this._tileIndexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint16Array(r),t.STATIC_DRAW)}isValidTile(t,e){return t>=0&&t<this.rows&&e>=0&&e<this.cols&&this._layout[t*this.cols+e]>=0}getTileCenterX(t){return this._tileSize*(t-.5*this.cols+.5)}getTileCenterZ(t){return this._tileSize*(t-.5*this.rows+.5)}canExitTile(t,e,r){if(r<0||r>=4||t<0||t>=this.rows||e<0||e>=this.cols)return!0;const i=this._layout[t*this.cols+e];return i<0||this._tiles[i].exits[r]}render(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++){const i=this._layout[e*this.cols+r];i>=0&&(t.saveMvMatrix(),this._tempVec[0]=r*this._tileSize-this.cols*this._tileSize/2,this._tempVec[1]=0,this._tempVec[2]=e*this._tileSize-this.rows*this._tileSize/2,mat4.translate(t.mvMatrix,this._tempVec),this._shader.render(t,this._tiles[i]),t.restoreMvMatrix())}}configureAsync(t,e){this.rows=0|t.rows,this.cols=0|t.cols,this._layout=t.layout;const r=[],i=t.tiles;for(let i=0,s=t.tiles.length;i<s;i++){const s=t.tiles[i];r.push(e.getTextureAsync(s.texture))}return r.push(e.getModelShaderAsync(t.shader)),Promise.all(r).then(t=>{const e=t.length-1;this._shader=t[e];for(let r=0;r<e;r++)this._tiles.push(new GroundTile(t[r],this._tileIndexCount,this._tileIndexBuffer,this._tileVertexBuffer,this._tileTexCoordBuffer,i[r].exits))})}}class MultiQuadStripModel extends Model{constructor(){super(...arguments),this.shader=null,this.parts=new Array}render(t){for(let e=0,r=this.parts.length;e<r;e++)this.shader.render(t,this.parts[e])}configureAsync(t,e){const r=e.gl;let i=null;const s=[e.getModelShaderAsync(t.shader)];for(let o=0,n=t.parts.length;o<n;o++)this.parts.push(i=new MultiQuadStripModelPart(r)),s.push(i.configureAsync(t.parts[o],e));return Promise.all(s).then(t=>{this.shader=t[0]})}}class MultiQuadStripModelPart{constructor(t){this.texture=null,this.indexCount=0,this.indexBuffer=null,this.vertexBuffer=null,this.texCoordBuffer=null,this.texture=null,this.indexCount=0,this.indexBuffer=t.createBuffer(),this.vertexBuffer=t.createBuffer(),this.texCoordBuffer=t.createBuffer()}configureAsync(t,e){const r=t.coords.length/3|0,i=Math.floor(r/2)-1,s=new Float32Array(2*r),o=new Uint16Array(3*(r-2));let n=0;for(let t=0,e=s.length;t<e;t+=4){const e=n/i;s[t+0]=e,s[t+1]=0,s[t+2]=e,s[t+3]=1,n+=1}for(let t=0;t<i;t++)o[6*t+0]=2*t+0,o[6*t+1]=2*t+1,o[6*t+2]=2*t+2,o[6*t+3]=2*t+2,o[6*t+4]=2*t+1,o[6*t+5]=2*t+3;this.indexCount=o.length;const a=e.gl;return a.bindBuffer(a.ARRAY_BUFFER,this.vertexBuffer),a.bufferData(a.ARRAY_BUFFER,new Float32Array(t.coords),a.STATIC_DRAW),a.bindBuffer(a.ARRAY_BUFFER,this.texCoordBuffer),a.bufferData(a.ARRAY_BUFFER,s,a.STATIC_DRAW),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,this.indexBuffer),a.bufferData(a.ELEMENT_ARRAY_BUFFER,o,a.STATIC_DRAW),e.getTextureAsync(t.texture).then(t=>this.texture=t)}}class TranslateTransform extends Renderable{constructor(t,e){super(),this._renderable=t,this._x=e[0],this._y=e[1],this._z=e[2],this._data=e}render(t){t.saveMvMatrix(),mat4.translate(t.mvMatrix,this._data),this._renderable.render(t),t.restoreMvMatrix()}}class RotateTransform extends Renderable{constructor(t,e,r){super(),this._renderable=t,this._axis=r,this._angle=e*(Math.PI/180)}render(t){t.saveMvMatrix(),mat4.rotate(t.mvMatrix,2*Math.PI*(Date.now()%5e3/5e3),this._axis),this._renderable.render(t),t.restoreMvMatrix()}}class WorldModel extends Model{constructor(){super(...arguments),this._objects=new Array}render(t){for(let e=0,r=this._objects.length;e<r;e++)this._objects[e].render(t)}configureAsync(t,e){const r=[],i=new Map;for(let s in t.models)r.push(this._loadModel(i,s,t.models[s],e));return Promise.all(r).then(()=>{this._parseObjects(i,t.objects),this._parseVehicles(i,t.vehicles)})}_loadModel(t,e,r,i){return Model.loadAsync(r,i).then(r=>{t.set(e,r)})}_parseObjects(t,e){for(let r=0;r<e.length;r++){let i=e[r],s=this._getModelOrThrow(t,i.model);const o=i.transform;if("object"==typeof o)if(o instanceof Array)for(let t=0;t<o.length;t++)s=this._applyTransform(s,o[t]);else s=this._applyTransform(s,o);this._objects.push(s)}}_applyTransform(t,e){return e.translate?new TranslateTransform(t,e.translate):e.rotate?new RotateTransform(t,e.rotate,e.axis):t}_parseVehicles(t,e){const r=this._getModelOrThrow(t,"ground");for(let i=0;i<e.length;i++){const s=e[i],o=s.count||0,n=this._getModelOrThrow(t,s.model);for(let t=0;t<o;t++)this._objects.push(new Vehicle(n,r))}}_getModelOrThrow(t,e){const r=t.get(e)||null;if(!r)throw new Error(`No model with key=${e}`);return r}}class SkyModel extends Model{constructor(t){super(),this.shader=null,this.texture=null,this.indexCount=0,this.indexBuffer=t.createBuffer(),this.vertexBuffer=t.createBuffer(),this.texCoordBuffer=t.createBuffer()}render(t){this.shader.render(t,this)}configureAsync(t,e){const r=e.gl,i=1e3,s=1/8,o=new Float32Array([0,1,1*s,1,1*s,0,0,0,1*s,1,.25,1,.25,0,1*s,0,.25,1,3*s,1,3*s,0,.25,0,3*s,1,.5,1,.5,0,3*s,0,.6875,1,.6875,0,.5625,0,.5625,1,.875,0,.75,0,.75,1,.875,1]),n=new Float32Array([-i,i,i,-i,i,-i,-i,-i,-i,-i,-i,i,-i,i,-i,i,i,-i,i,-i,-i,-i,-i,-i,i,i,-i,i,i,i,i,-i,i,i,-i,-i,i,i,i,-i,i,i,-i,-i,i,i,-i,i,-i,i,i,i,i,i,i,i,-i,-i,i,-i,-i,-i,i,-i,-i,-i,i,-i,-i,i,-i,i]),a=new Uint16Array([2,1,0,2,0,3,6,5,4,6,4,7,10,9,8,10,8,11,14,13,12,14,12,15,18,17,16,18,16,19,22,21,20,22,20,23]);return this.indexCount=36,r.bindBuffer(r.ARRAY_BUFFER,this.vertexBuffer),r.bufferData(r.ARRAY_BUFFER,n,r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,this.texCoordBuffer),r.bufferData(r.ARRAY_BUFFER,o,r.STATIC_DRAW),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,this.indexBuffer),r.bufferData(r.ELEMENT_ARRAY_BUFFER,a,r.STATIC_DRAW),Promise.all([e.getModelShaderAsync(t.shader),e.getTextureAsync(t.texture)]).then(t=>{this.shader=t[0],this.texture=t[1]})}}class RawVerticiesModel extends Model{constructor(t){super(),this.indexCount=0,this.texture=null,this.shader=null,this.indexBuffer=null,this.vertexBuffer=null,this.normalBuffer=null,this.texCoordBuffer=null,this.indexBuffer=t.createBuffer(),this.vertexBuffer=t.createBuffer(),this.normalBuffer=t.createBuffer(),this.texCoordBuffer=t.createBuffer()}render(t){this.shader.render(t,this)}configureAsync(t,e){this.indexCount=t.indicies.length;const r=e.gl;return this._buildIndexBuffer(r,this.indexBuffer,t.indicies),this._buildArrayBuffer(r,this.vertexBuffer,t.vertices),this._buildArrayBuffer(r,this.normalBuffer,t.normals),this._buildArrayBuffer(r,this.texCoordBuffer,t.texCoords),Promise.all([e.getTextureAsync(t.texture),e.getModelShaderAsync(t.shader)]).then(t=>{this.texture=t[0],this.shader=t[1]})}_buildArrayBuffer(t,e,r){t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,new Float32Array(r),t.STATIC_DRAW)}_buildIndexBuffer(t,e,r){const i=t.ELEMENT_ARRAY_BUFFER;t.bindBuffer(i,e),t.bufferData(i,new Uint16Array(r),t.STATIC_DRAW)}}let gl=null,res=null,modelView=null,worldModel=null,initialized=!1,viewportWidth=0,viewportHeight=0;function initGL(t){try{t.width=t.offsetWidth,t.height=t.offsetHeight,t.onpointerdown=function(){t.requestPointerLock()},gl=t.getContext("webgl")||t.getContext("experimental-webgl"),viewportWidth=t.offsetWidth,viewportHeight=t.offsetHeight,modelView=new ModelView(gl),res=new ResourceLoader(gl)}catch(t){console.warn(t)}gl||alert("Could not initialize WebGL")}function drawScene(){gl.viewport(0,0,viewportWidth,viewportHeight),gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT),mat4.perspective(45,viewportWidth/viewportHeight,1,2e3,modelView.pjMatrix),worldModel.render(modelView),modelView.finishFrame()}function tick(){drawScene(),requestAnimationFrame(tick)}function startup(){initGL(document.getElementById("content")),res.addModelType("world",WorldModel),res.addModelType("sky",SkyModel),res.addModelType("camera",CameraModel),res.addModelType("ground",GroundModel),res.addModelType("building",BuildingModel),res.addModelType("rawVerticies",RawVerticiesModel),res.addModelType("multiQuadStrip",MultiQuadStripModel),Promise.all([Promise.all([res.createShaderProgramAsync("shaders/Diffuse-Vertex.glsl","shaders/Diffuse-Fragment.glsl"),res.createShaderProgramAsync("shaders/Normal-Vertex.glsl","shaders/Normal-Fragment.glsl")]).then(t=>res.addModelShader("diffuse",new DiffuseShader(gl,t[0],t[1]))),res.createShaderProgramAsync("shaders/Flat-Vertex.glsl","shaders/Flat-Fragment.glsl").then(t=>res.addModelShader("flat",new FlatShader(gl,t)))]).then(()=>Model.loadAsync("models/World.json",res).then(t=>worldModel=t)).then(t=>{gl.clearColor(0,0,0,1),gl.enable(gl.DEPTH_TEST),gl.enable(gl.CULL_FACE),gl.cullFace(gl.BACK),window.onresize=handleResize;const e=document.getElementById("loader");e.parentElement.removeChild(e),initialized=!0,tick()})}function handleResize(){const t=document.getElementById("content");t.width=t.offsetWidth,t.height=t.offsetHeight,viewportWidth=t.offsetWidth,viewportHeight=t.offsetHeight,initialized&&drawScene()}function V3_mul_S1(t,e,r,i,s){const o=3*e,n=3*i;t[o+0]=s*r[n+0],t[o+1]=s*r[n+1],t[o+2]=s*r[n+2]}function V3_add_V3(t,e,r,i,s,o){const n=3*e,a=3*i,h=3*o;t[n+0]=r[a+0]+s[h+0],t[n+1]=r[a+1]+s[h+1],t[n+2]=r[a+2]+s[h+2]}function V3_sub_V3(t,e,r,i,s,o){const n=3*e,a=3*i,h=3*o;t[n+0]=r[a+0]-s[h+0],t[n+1]=r[a+1]-s[h+1],t[n+2]=r[a+2]-s[h+2]}function V3_copy_V3(t,e,r,i){const s=3*e,o=3*i;t[s+0]=r[o+0],t[s+1]=r[o+1],t[s+2]=r[o+2]}function M4_mul_V4(t,e,r,i,s){const o=4*e,n=4*s,a=i[n+0],h=i[n+1],l=i[n+2],_=i[n+3];t[o+0]=a*r[0]+h*r[1]+l*r[2]+_*r[3],t[o+1]=a*r[4]+h*r[5]+l*r[6]+_*r[7],t[o+2]=a*r[8]+h*r[9]+l*r[10]+_*r[11],t[o+3]=a*r[12]+h*r[13]+l*r[14]+_*r[15]}function M4_mul_M4(t,e,r){const i=e[0],s=e[1],o=e[2],n=e[3],a=e[4],h=e[5],l=e[6],_=e[7],c=e[8],d=e[9],u=e[10],f=e[11],m=e[12],A=e[13],x=e[14],g=e[15];let M=r[0],p=r[1],R=r[2],B=r[3];t[0]=M*i+p*a+R*c+B*m,t[1]=M*s+p*h+R*d+B*A,t[2]=M*o+p*l+R*u+B*x,t[3]=M*n+p*_+R*f+B*g,M=r[4],p=r[5],R=r[6],B=r[7],t[4]=M*i+p*a+R*c+B*m,t[5]=M*s+p*h+R*d+B*A,t[6]=M*o+p*l+R*u+B*x,t[7]=M*n+p*_+R*f+B*g,M=r[8],p=r[9],R=r[10],B=r[11],t[8]=M*i+p*a+R*c+B*m,t[9]=M*s+p*h+R*d+B*A,t[10]=M*o+p*l+R*u+B*x,t[11]=M*n+p*_+R*f+B*g,M=r[12],p=r[13],R=r[14],B=r[15],t[12]=M*i+p*a+R*c+B*m,t[13]=M*s+p*h+R*d+B*A,t[14]=M*o+p*l+R*u+B*x,t[15]=M*n+p*_+R*f+B*g}class Vehicle extends Renderable{constructor(t,e){super(),this._model=t,this._ground=e,this._pos=new Float32Array(3),this._path=new Spline3(4),this._locations=new Float32Array(12),this._locationI=0,this._duration=3e3*Math.random()+1500|0,this._timeIndex=0,this._row=-1,this._col=-1,this._direction=4*Math.random()|0,this._angleXz=2*Math.PI*Math.random(),this._x=0,this._z=0,this._y=0;do{this._row=Math.floor(e.rows*Math.random()),this._col=Math.floor(e.cols*Math.random())}while(!e.isValidTile(this._row,this._col));let r=e.getTileCenterX(this._col),i=e.getTileCenterZ(this._row),s=10*Math.random()+3;this._locations[0]=r,this._locations[1]=s,this._locations[2]=i,this._locationI=1,this._x=r,this._y=s,this._z=i,this._nextLocation(),this._nextLocation(),this._nextLocation(),this._updatePath()}render(t){const e=Date.now()%this._duration/this._duration,r=Date.now()/this._duration|0;this._timeIndex!=r&&(this._timeIndex=r,this._nextLocation(),this._updatePath()),this._path.interpolate(this._pos,0,1/3+1/3*Math.min(e,1));const i=this._pos[0]-this._x,s=this._pos[2]-this._z;(Math.abs(i)>.1||Math.abs(s)>.1)&&(this._angleXz=Math.atan2(i,s),this._x=this._pos[0],this._z=this._pos[2]),t.saveMvMatrix(),mat4.translate(t.mvMatrix,this._pos),mat4.translate(t.mvMatrix,[1,1,1]),mat4.rotate(t.mvMatrix,this._angleXz,[0,1,0]),mat4.translate(t.mvMatrix,[-1,-1,-1]),this._model.render(t),t.restoreMvMatrix()}_nextLocation(){const t=this._direction;do{this._direction=Vehicle.nextDirections[3*t+(3*Math.random()|0)]}while(!this._ground.canExitTile(this._row,this._col,this._direction));this._row+=Vehicle.nextRow[this._direction],this._col+=Vehicle.nextCol[this._direction];const e=Math.min(Math.max(this._y+10*Math.random()-5,3),50),r=3*this._locationI;this._locations[r+0]=this._ground.getTileCenterX(this._col),this._locations[r+1]=e,this._locations[r+2]=this._ground.getTileCenterZ(this._row),this._y=e,this._locationI=(this._locationI+1)%4}_updatePath(){for(let t=0;t<4;t++){const e=(this._locationI+t)%4*3;this._path.set(t,this._locations[e+0],this._locations[e+1],this._locations[e+2])}}}Vehicle.nextRow=[-1,0,1,0],Vehicle.nextCol=[0,1,0,-1],Vehicle.nextDirections=[0,1,3,0,1,2,1,2,3,0,2,3];